[33m===Dynamic model for quaternion module===[0m
===AOCS Scilab===


------------------------------------
     CelestLab - Version 3.0.0
           CNES - DCT/SB
------------------------------------


Start Aerospace blockset - (2.0)
	Load macros
	Load reference frames palette
	Load math oparations palette
	Load unit conversions palette
	Load environment palette
	Load orbit propagators palette
	Load utilities palette
	Load help
	Load demos

 
-->// This function compute the torque that should be generated by each thruster
 
-->// The solution is based on the Least Norm method that compute the smaller 
 
-->// solution of a underdetermined linear equation.
 
-->// Ba is the thrusters geometric configuration matrix and Controller_Torque 
 
-->// is the torque coming from the Controller.
 
-->// The Linear equation we are solving is:
 
-->// Ba*U = T_c;
 
 
-->function [Torques] = LeastNormTorque(Ba, Controller_Torque)
-->    Torque_Factor = Ba' / (Ba * Ba');
-->    Torques  = Torque_Factor * Controller_Torque;
-->endfunction
 
 
-->// This function is the angular rate controller.
 
-->// It use the Nonlinear Dynamic Inversion technique
 
-->// The inputs are: actual angular velocity, and desired angular velocity
 
-->// Ix,Iy, Iz are defined in simulation context
 
-->// Reference : Control System Application
 
 
-->function [NDI_torque]= NDI_rateControl(w, wd)
-->    // Controller Gain (can be change for performance)
-->    Cx = 10*Ix;
-->    Cy = 10*Iy;
-->    Cz = 10*Iz;
-->    Ux = -(Iy - Iz)*w(2)*w(3) - Cx*(w(1) - wd(1));
-->    Uy = -(Iz - Ix)*w(3)*w(1) - Cy*(w(2) - wd(2));
-->    Uz = -(Ix - Iy)*w(1)*w(2) - Cz*(w(3) - wd(3));
-->    NDI_torque = [Ux; Uy; Uz];
-->endfunction
 
 
-->// This function compute the matrix [Î©'] for quaternion kinematics
 
-->// Its input is the satellite angular velocity given in satellite
 
-->// body-frame.
 
-->// Reference: Strapdown Attitude Algorithms using Quaternion Transition Matrix And Random Inputs, Mohamed S.Ahmed (Attitude control)
 
 
-->function [Omega] = OmegaPrime(w)
-->    Omega = [ 0    ,  -w(1)  , -w(2) ,  -w(3);
-->              w(1) ,   0     ,  w(3) ,  -w(2);
-->              w(2) ,  -w(3) ,  0    ,  w(1);
-->              w(3) ,   w(2) , -w(1) ,  0     ];
-->endfunction
 
 
-->// Attitude Controller with Quaternion feedback
 
-->// The parameters Kx, Ky, Kz, Kxd, Kyd, Kzd are defined in the CONTEXT
 
-->// The first element in the quaternion is the constant element.
 
 
-->function [Torque] = QuaternionPD(q, w)
-->    Kx  = 0.005;    
-->    Ky  = 0.005;
-->    Kz  = 0.006;
-->    Kxd = -0.3;
-->    Kyd = -0.3;
-->    Kzd = -0.3;
-->    Torque = [ 2*Kx*q(1)*q(2) + Kxd*w(1);
-->               2*Ky*q(1)*q(3) + Kyd*w(2);
-->               2*Kz*q(1)*q(4) + Kzd*w(3)];
-->endfunction
 
 
-->// Definition of some constants:
 
-->// Inertia of the satellite and momentum wheel
 
 
-->Ix=41.87e-3; 
 
-->Iy=41.87e-3;
 
-->Iz=6.667e-3;
 
-->Ixy=0.0;
 
-->Ixz=0.0;
 
-->Iyz=0.0;
 
-->I_Sat = [ Ix,  Ixy, Ixz  ;
-->          Ixy, Iy , Iyz  ;
-->          Ixz, Iyz, Iz   ];
 
 
-->Iwx=2E-6;   // Wheel on x-axis
 
-->Iwy=Iwx;
 
-->Iwz=Iwx;
 
-->I_wheels = [Iwx, 0  , 0   ;
-->            0  , Iwy, 0   ;
-->            0  , 0  , Iwz ];
 
 
 
-->//Thruster Geometric Configuration
 
-->// COM = center of mass
 
-->// GC  = geometric center
 
 
-->X_COM=0.00;   // X position of the COM with respect to GC
 
-->Y_COM=0.000;  // Y position of the COM with respect to GC
 
-->Z_COM=0.000;  // Z position of the COM with respect to GC
 
 
-->COM   = [X_COM; Y_COM; Z_COM];
 
 
-->// T1, T2, T3, and T4 are the Thruster Torque Orientation with respect to the 
 
-->// Body frame. We will normalize these vectors in order to get unit vector and
 
-->// Then compute the Unit Torque per thruster.
 
 
-->// Thruster 1
 
-->T1=[0;-0.259;0.966];                  // Thrust vector
 
-->T1= T1 ./ sqrt(T1' * T1);                 // Normalized Thrust Vector
 
-->OM1=[0.0305;-0.0419;-0.15275] - COM;    // Thruster Position With respect to COM
 
-->To1= cross(OM1, T1);                       // Torque vector
 
 
-->// Thruster 2
 
-->T2=[0;-0.259;0.966]; 
 
-->T2=T2 ./ sqrt(T2' * T2);
 
-->OM2=[-0.0305;-0.0419;-0.15275] - COM;
 
-->To2= cross(OM2, T2);
 
 
-->// Thruster 3
 
-->T3=[0;0.259;0.966];
 
-->T3=T3 ./ sqrt(T3' * T3);
 
-->OM3=[-0.0305;0.0419;-0.15275] - COM;
 
-->To3=cross(OM3, T3);
 
 
-->// Thruster 4
 
-->T4=[0;0.259;0.966];
 
-->T4=T4 ./sqrt(T4' * T4);
 
-->OM4=[0.0305;0.0419;-0.15275] - COM;
 
-->To4= cross(OM4, T4);
 
 
-->Ba=[To1,To2,To3,To4];
 
 
-->// Thruster Impulse
 
-->Thruster_Impulse_max=60e-6;
 
-->Thruster_Impulse_min=30e-6;
 
-->Thruster_on=50;               // This define the Duty cycle of the thruster in percentage
 
-->Thruster_period=1;                // This is the period of the thruster. It is the inverse
 
-->                                     // of the frequency.        
 
 
-->// Simulation Configuration: sim time, ...
 
-->T_sim=300;
 
-->Max_Step_Size=0.05;                // Maximum time step for simulation (used for integration)
 
 
-->// Controller Setup
 
 
-->    // 1. Rate Controller
 
-->         W_desired=[0;0.1;0];  //Desired Angular velocity
 
 
-->    // 2. Attitude Controller (angle controller)
 
-->         q_desired=[0.866;0;0;0.5];  // Desired attitude quaternion 
 
